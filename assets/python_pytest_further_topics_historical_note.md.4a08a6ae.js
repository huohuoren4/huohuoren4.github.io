import{_ as s,o as e,c as a,Q as n}from"./chunks/framework.01af844e.js";const m=JSON.parse('{"title":"Historical Notes","description":"","frontmatter":{},"headers":[],"relativePath":"python/pytest/further_topics/historical_note.md","filePath":"python/pytest/further_topics/historical_note.md","lastUpdated":1692807718000}'),t={name:"python/pytest/further_topics/historical_note.md"},o=n(`<h1 id="historical-notes" tabindex="-1">Historical Notes <a class="header-anchor" href="#historical-notes" aria-label="Permalink to &quot;Historical Notes {#historical-notes}&quot;">​</a></h1><p>This page lists features or behavior from previous versions of pytest which have changed over the years. They are kept here as a historical note so users looking at old code can find documentation related to them.</p><h2 id="marker-revamp-and-iteration" tabindex="-1">Marker revamp and iteration <a class="header-anchor" href="#marker-revamp-and-iteration" aria-label="Permalink to &quot;Marker revamp and iteration {#marker-revamp-and-iteration}&quot;">​</a></h2><p><em>Changed in version 3.6.</em></p><p>pytest’s marker implementation traditionally worked by simply updating the <code>__dict__</code> attribute of functions to cumulatively add markers. As a result, markers would unintentionally be passed along class hierarchies in surprising ways. Further, the API for retrieving them was inconsistent, as markers from parameterization would be stored differently than markers applied using the <code>@pytest.mark</code> decorator and markers added via <code>node.add_marker</code>.</p><p>This state of things made it technically next to impossible to use data from markers correctly without having a deep understanding of the internals, leading to subtle and hard to understand bugs in more advanced usages.</p><p>Depending on how a marker got declared/changed one would get either a <code>MarkerInfo</code> which might contain markers from sibling classes, <code>MarkDecorators</code> when marks came from parameterization or from a <code>node.add_marker</code> call, discarding prior marks. Also <code>MarkerInfo</code> acts like a single mark, when it in fact represents a merged view on multiple marks with the same name.</p><p>On top of that markers were not accessible in the same way for modules, classes, and functions/methods. In fact, markers were only accessible in functions, even if they were declared on classes/modules.</p><p>A new API to access markers has been introduced in pytest 3.6 in order to solve the problems with the initial design, providing the <code>_pytest.nodes.Node.iter_markers()</code> method to iterate over markers in a consistent manner and reworking the internals, which solved a great deal of problems with the initial design.</p><h3 id="updating-code" tabindex="-1">Updating code <a class="header-anchor" href="#updating-code" aria-label="Permalink to &quot;Updating code {#updating-code}&quot;">​</a></h3><p>The old <code>Node.get_marker(name)</code> function is considered deprecated because it returns an internal <code>MarkerInfo</code> object which contains the merged name, <code>*args</code> and <code>**kwargs</code> of all the markers which apply to that node.</p><p>In general there are two scenarios on how markers should be handled:</p><ol><li><p>Marks overwrite each other. Order matters but you only want to think of your mark as a single item. E.g. <code>log_level(&#39;info&#39;)</code> at a module level can be overwritten by <code>log_level(&#39;debug&#39;)</code> for a specific test.</p><p>In this case, use <code>Node.get_closest_marker(name)</code>:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># replace this:</span></span>
<span class="line"><span style="color:#E1E4E8;">marker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> item.get_marker(</span><span style="color:#9ECBFF;">&quot;log_level&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> marker:</span></span>
<span class="line"><span style="color:#E1E4E8;">    level </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> marker.args[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># by this:</span></span>
<span class="line"><span style="color:#E1E4E8;">marker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> item.get_closest_marker(</span><span style="color:#9ECBFF;">&quot;log_level&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> marker:</span></span>
<span class="line"><span style="color:#E1E4E8;">    level </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> marker.args[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># replace this:</span></span>
<span class="line"><span style="color:#24292E;">marker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> item.get_marker(</span><span style="color:#032F62;">&quot;log_level&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> marker:</span></span>
<span class="line"><span style="color:#24292E;">    level </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> marker.args[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># by this:</span></span>
<span class="line"><span style="color:#24292E;">marker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> item.get_closest_marker(</span><span style="color:#032F62;">&quot;log_level&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> marker:</span></span>
<span class="line"><span style="color:#24292E;">    level </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> marker.args[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]</span></span></code></pre></div></li><li><p>Marks compose in an additive manner. E.g. <code>skipif(condition)</code> marks mean you just want to evaluate all of them, order doesn’t even matter. You probably want to think of your marks as a set here.</p><p>In this case iterate over each mark and handle their <code>*args</code> and <code>**kwargs</code> individually.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># replace this</span></span>
<span class="line"><span style="color:#E1E4E8;">skipif </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> item.get_marker(</span><span style="color:#9ECBFF;">&quot;skipif&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> skipif:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> condition </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> skipif.args:</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;"># eval condition</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># by this:</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> skipif </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> item.iter_markers(</span><span style="color:#9ECBFF;">&quot;skipif&quot;</span><span style="color:#E1E4E8;">):</span></span>
<span class="line"><span style="color:#E1E4E8;">    condition </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> skipif.args[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;"># eval condition</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># replace this</span></span>
<span class="line"><span style="color:#24292E;">skipif </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> item.get_marker(</span><span style="color:#032F62;">&quot;skipif&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> skipif:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> condition </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> skipif.args:</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;"># eval condition</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># by this:</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> skipif </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> item.iter_markers(</span><span style="color:#032F62;">&quot;skipif&quot;</span><span style="color:#24292E;">):</span></span>
<span class="line"><span style="color:#24292E;">    condition </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> skipif.args[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;"># eval condition</span></span></code></pre></div></li></ol><p>If you are unsure or have any questions, please consider opening <a href="https://github.com/pytest-dev/pytest/issues/new" target="_blank" rel="noreferrer">an issue</a>.</p><h3 id="related-issues" tabindex="-1">Related issues <a class="header-anchor" href="#related-issues" aria-label="Permalink to &quot;Related issues {#related-issues}&quot;">​</a></h3><p>Here is a non-exhaustive list of issues fixed by the new implementation:</p><ul><li><p>Marks don’t pick up nested classes (<a href="https://github.com/pytest-dev/pytest/issues/199" target="_blank" rel="noreferrer">issue #199</a>).</p></li><li><p>Markers stain on all related classes (<a href="https://github.com/pytest-dev/pytest/issues/568" target="_blank" rel="noreferrer">issue #568</a>).</p></li><li><p>Combining marks - args and kwargs calculation (<a href="https://github.com/pytest-dev/pytest/issues/2897" target="_blank" rel="noreferrer">issue #2897</a>).</p></li><li><p><code>request.node.get_marker(&#39;name&#39;)</code> returns <code>None</code> for markers applied in classes (<a href="https://github.com/pytest-dev/pytest/issues/902" target="_blank" rel="noreferrer">issue #902</a>).</p></li><li><p>Marks applied in parametrize are stored as markdecorator (<a href="https://github.com/pytest-dev/pytest/issues/2400" target="_blank" rel="noreferrer">issue #2400</a>).</p></li><li><p>Fix marker interaction in a backward incompatible way (<a href="https://github.com/pytest-dev/pytest/issues/1670" target="_blank" rel="noreferrer">issue #1670</a>).</p></li><li><p>Refactor marks to get rid of the current “marks transfer” mechanism (<a href="https://github.com/pytest-dev/pytest/issues/2363" target="_blank" rel="noreferrer">issue #2363</a>).</p></li><li><p>Introduce FunctionDefinition node, use it in generate_tests (<a href="https://github.com/pytest-dev/pytest/issues/2522" target="_blank" rel="noreferrer">issue #2522</a>).</p></li><li><p>Remove named marker attributes and collect markers in items (<a href="https://github.com/pytest-dev/pytest/issues/891" target="_blank" rel="noreferrer">issue #891</a>).</p></li><li><p>skipif mark from parametrize hides module level skipif mark (<a href="https://github.com/pytest-dev/pytest/issues/1540" target="_blank" rel="noreferrer">issue #1540</a>).</p></li><li><p>skipif + parametrize not skipping tests (<a href="https://github.com/pytest-dev/pytest/issues/1296" target="_blank" rel="noreferrer">issue #1296</a>).</p></li><li><p>Marker transfer incompatible with inheritance (<a href="https://github.com/pytest-dev/pytest/issues/535" target="_blank" rel="noreferrer">issue #535</a>).</p></li></ul><p>More details can be found in the <a href="https://github.com/pytest-dev/pytest/pull/3317" target="_blank" rel="noreferrer">original PR</a>.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>in a future major release of pytest we will introduce class based markers, at which point markers will no longer be limited to instances of <code>Mark</code>.</p></div><h2 id="cache-plugin-integrated-into-the-core" tabindex="-1">cache plugin integrated into the core <a class="header-anchor" href="#cache-plugin-integrated-into-the-core" aria-label="Permalink to &quot;cache plugin integrated into the core {#cache-plugin-integrated-into-the-core}&quot;">​</a></h2><p>The functionality of the <a href="/python/pytest/how_to_guides/re_run#how-to-re-run-failed-tests-and-maintain-state-between-test-runs">core cache</a> plugin was previously distributed as a third party plugin named <code>pytest-cache</code>. The core plugin is compatible regarding command line options and API usage except that you can only store/receive data between test runs that is json-serializable.</p><h2 id="funcargs-and-pytest-funcarg" tabindex="-1">funcargs and <code>pytest_funcarg__</code> <a class="header-anchor" href="#funcargs-and-pytest-funcarg" aria-label="Permalink to &quot;funcargs and \`pytest_funcarg__\` {#funcargs-and-pytest-funcarg}&quot;">​</a></h2><p>In versions prior to 2.3 there was no <code>@pytest.fixture</code> marker and you had to use a magic <code>pytest_funcarg__NAME</code> prefix for the fixture factory. This remains and will remain supported but is not anymore advertised as the primary means of declaring fixture functions.</p><h2 id="pytest-yield-fixture-decorator" tabindex="-1"><code>@pytest.yield_fixture</code> decorator <a class="header-anchor" href="#pytest-yield-fixture-decorator" aria-label="Permalink to &quot;\`@pytest.yield_fixture\` decorator {#pytest-yield-fixture-decorator}&quot;">​</a></h2><p>Prior to version 2.10, in order to use a <code>yield</code> statement to execute teardown code one had to mark a fixture using the <code>yield_fixture</code> marker. From 2.10 onward, normal fixtures can use <code>yield</code> directly so the <code>yield_fixture</code> decorator is no longer needed and considered deprecated.</p><h2 id="pytest-header-in-setup-cfg" tabindex="-1"><code>[pytest]</code> header in <code>setup.cfg</code> <a class="header-anchor" href="#pytest-header-in-setup-cfg" aria-label="Permalink to &quot;\`[pytest]\` header in \`setup.cfg\` {#pytest-header-in-setup-cfg}&quot;">​</a></h2><p>Prior to 3.0, the supported section name was <code>[pytest]</code>. Due to how this may collide with some distutils commands, the recommended section name for <code>setup.cfg</code> files is now <code>[tool:pytest]</code>.</p><p>Note that for <code>pytest.ini</code> and <code>tox.ini</code> files the section name is <code>[pytest]</code>.</p><h2 id="applying-marks-to-pytest-mark-parametrize-parameters" tabindex="-1">Applying marks to <code>@pytest.mark.parametrize</code> parameters <a class="header-anchor" href="#applying-marks-to-pytest-mark-parametrize-parameters" aria-label="Permalink to &quot;Applying marks to \`@pytest.mark.parametrize\` parameters {#applying-marks-to-pytest-mark-parametrize-parameters}&quot;">​</a></h2><p>Prior to version 3.1 the supported mechanism for marking values used the syntax:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> pytest</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">@pytest.mark.parametrize</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;test_input,expected&quot;</span><span style="color:#E1E4E8;">, [(</span><span style="color:#9ECBFF;">&quot;3+5&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">), (</span><span style="color:#9ECBFF;">&quot;2+4&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">), pytest.mark.xfail((</span><span style="color:#9ECBFF;">&quot;6*9&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">42</span><span style="color:#E1E4E8;">))]</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">test_eval</span><span style="color:#E1E4E8;">(test_input, expected):</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">assert</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">eval</span><span style="color:#E1E4E8;">(test_input) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> expected</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> pytest</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">@pytest.mark.parametrize</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;test_input,expected&quot;</span><span style="color:#24292E;">, [(</span><span style="color:#032F62;">&quot;3+5&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">8</span><span style="color:#24292E;">), (</span><span style="color:#032F62;">&quot;2+4&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">6</span><span style="color:#24292E;">), pytest.mark.xfail((</span><span style="color:#032F62;">&quot;6*9&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">42</span><span style="color:#24292E;">))]</span></span>
<span class="line"><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">test_eval</span><span style="color:#24292E;">(test_input, expected):</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">assert</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">eval</span><span style="color:#24292E;">(test_input) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> expected</span></span></code></pre></div><p>This was an initial hack to support the feature but soon was demonstrated to be incomplete, broken for passing functions or applying multiple marks with the same name but different parameters.</p><p>The old syntax is planned to be removed in pytest-4.0.</p><h2 id="pytest-mark-parametrize-argument-names-as-a-tuple" tabindex="-1"><code>@pytest.mark.parametrize</code> argument names as a tuple <a class="header-anchor" href="#pytest-mark-parametrize-argument-names-as-a-tuple" aria-label="Permalink to &quot;\`@pytest.mark.parametrize\` argument names as a tuple {#pytest-mark-parametrize-argument-names-as-a-tuple}&quot;">​</a></h2><p>In versions prior to 2.4 one needed to specify the argument names as a tuple. This remains valid but the simpler <code>&quot;name1,name2,...&quot; </code>comma-separated-string syntax is now advertised first because it’s easier to write and produces less line noise.</p><h2 id="setup-is-now-an-autouse-fixture" tabindex="-1">setup: is now an &quot;autouse fixture&quot; <a class="header-anchor" href="#setup-is-now-an-autouse-fixture" aria-label="Permalink to &quot;setup: is now an &quot;autouse fixture&quot; {#setup-is-now-an-autouse-fixture}&quot;">​</a></h2><p>During development prior to the pytest-2.3 release the name <code>pytest.setup</code> was used but before the release it was renamed and moved to become part of the general fixture mechanism, namely <a href="/python/pytest/how_to_guides/fixture#autouse-fixtures-fixtures-you-don-t-have-to-request">Autouse fixtures (fixtures you don&#39;t have to request)</a></p><h2 id="conditions-as-strings-instead-of-booleans" tabindex="-1">Conditions as strings instead of booleans <a class="header-anchor" href="#conditions-as-strings-instead-of-booleans" aria-label="Permalink to &quot;Conditions as strings instead of booleans {#conditions-as-strings-instead-of-booleans}&quot;">​</a></h2><p>Prior to pytest-2.4 the only way to specify skipif/xfail conditions was to use strings:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> sys</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">@pytest.mark.skipif</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;sys.version_info &gt;= (3,3)&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">test_function</span><span style="color:#E1E4E8;">():</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">...</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> sys</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">@pytest.mark.skipif</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;sys.version_info &gt;= (3,3)&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">test_function</span><span style="color:#24292E;">():</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">...</span></span></code></pre></div><p>During test function setup the skipif condition is evaluated by calling <code>eval(&#39;sys.version_info &gt;= (3,0)&#39;, namespace)</code>. The namespace contains all the module globals, and os and sys as a minimum.</p><p>Since pytest-2.4 <a href="/python/pytest/how_to_guides/skip_xfail#skipping-test-functions">boolean conditions</a> are considered preferable because markers can then be freely imported between test modules. With strings you need to import not only the marker but all variables used by the marker, which violates encapsulation.</p><p>The reason for specifying the condition as a string was that <code>pytest</code> can report a summary of skip conditions based purely on the condition string. With conditions as booleans you are required to specify a <code>reason</code> string.</p><p>Note that string conditions will remain fully supported and you are free to use them if you have no need for cross-importing markers.</p><p>The evaluation of a condition string in <code>pytest.mark.skipif(conditionstring)</code> or <code>pytest.mark.xfail(conditionstring)</code> takes place in a namespace dictionary which is constructed as follows:</p><ul><li><p>the namespace is initialized by putting the <code>sys</code> and <code>os</code> modules and the pytest <code>config</code> object into it.</p></li><li><p>updated with the module globals of the test function for which the expression is applied.</p></li></ul><p>The pytest <code>config</code> object allows you to skip based on a test configuration value which you might have added:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">@pytest.mark.skipif</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;not config.getvalue(&#39;db&#39;)&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">test_function</span><span style="color:#E1E4E8;">():</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">...</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">@pytest.mark.skipif</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;not config.getvalue(&#39;db&#39;)&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">test_function</span><span style="color:#24292E;">():</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">...</span></span></code></pre></div><p>The equivalent with “boolean conditions” is:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">@pytest.mark.skipif</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">not</span><span style="color:#E1E4E8;"> pytest.config.getvalue(</span><span style="color:#9ECBFF;">&quot;db&quot;</span><span style="color:#E1E4E8;">), </span><span style="color:#FFAB70;">reason</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;--db was not specified&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">test_function</span><span style="color:#E1E4E8;">():</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">pass</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">@pytest.mark.skipif</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">not</span><span style="color:#24292E;"> pytest.config.getvalue(</span><span style="color:#032F62;">&quot;db&quot;</span><span style="color:#24292E;">), </span><span style="color:#E36209;">reason</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;--db was not specified&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">test_function</span><span style="color:#24292E;">():</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">pass</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>You cannot use <code>pytest.config.getvalue()</code> in code imported before pytest’s argument parsing takes place. For example, <code>conftest.py</code> files are imported before command line parsing and thus <code>config.getvalue()</code> will not execute correctly.</p></div><h2 id="pytest-set-trace" tabindex="-1">pytest.set_trace() <a class="header-anchor" href="#pytest-set-trace" aria-label="Permalink to &quot;pytest.set_trace() {#pytest-set-trace}&quot;">​</a></h2><p>Previous to version 2.4 to set a break point in code one needed to use <code>pytest.set_trace()</code>:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> pytest</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">test_function</span><span style="color:#E1E4E8;">():</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">...</span></span>
<span class="line"><span style="color:#E1E4E8;">    pytest.set_trace()  </span><span style="color:#6A737D;"># invoke PDB debugger and tracing</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> pytest</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">test_function</span><span style="color:#24292E;">():</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">...</span></span>
<span class="line"><span style="color:#24292E;">    pytest.set_trace()  </span><span style="color:#6A737D;"># invoke PDB debugger and tracing</span></span></code></pre></div><p>This is no longer needed and one can use the native <code>import pdb;pdb.set_trace()</code> call directly.</p><p>For more details see <a href="https://docs.pytest.org/en/latest/how-to/failures.html#breakpoints" target="_blank" rel="noreferrer">Setting breakpoints</a>.</p><h2 id="compat-properties" tabindex="-1">&quot;compat&quot; properties <a class="header-anchor" href="#compat-properties" aria-label="Permalink to &quot;&quot;compat&quot; properties {#compat-properties}&quot;">​</a></h2><p>Access of <code>Module</code>, <code>Function</code>, <code>Class</code>, <code>Instance</code>, <code>File</code> and <code>Item</code> through <code>Node</code> instances have long been documented as deprecated, but started to emit warnings from pytest <code>3.9</code> and onward.</p><p>Users should just <code>import pytest</code> and access those objects using the <code>pytest</code> module.</p>`,59),p=[o];function l(r,i,c,d,y,u){return e(),a("div",null,p)}const E=s(t,[["render",l]]);export{m as __pageData,E as default};
