import{_ as e,o as t,c as o,Q as r}from"./chunks/framework.01af844e.js";const k=JSON.parse('{"title":"Workloads","description":"","frontmatter":{},"headers":[],"relativePath":"container/k8s/concept/workload/overview.md","filePath":"container/k8s/concept/workload/overview.md","lastUpdated":1694607182000}'),a={name:"container/k8s/concept/workload/overview.md"},n=r('<h1 id="workloads" tabindex="-1">Workloads <a class="header-anchor" href="#workloads" aria-label="Permalink to &quot;Workloads&quot;">​</a></h1><p>A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of <a href="https://kubernetes.io/docs/concepts/workloads/pods" target="_blank" rel="noreferrer">pods</a>. In Kubernetes, a Pod represents a set of running containers on your cluster.</p><p>Kubernetes pods have a <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noreferrer">defined lifecycle</a>. For example, once a pod is running in your cluster then a critical fault on the node where that pod is running means that all the pods on that node fail. Kubernetes treats that level of failure as final: you would need to create a new Pod to recover, even if the node later becomes healthy.</p><p>However, to make life considerably easier, you don&#39;t need to manage each Pod directly. Instead, you can use workload resources that manage a set of pods on your behalf. These resources configure controllers that make sure the right number of the right kind of pod are running, to match the state you specified.</p><p>Kubernetes provides several built-in workload resources:</p><ul><li><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noreferrer">Deployment</a> and <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noreferrer">ReplicaSet</a> (replacing the legacy resource ReplicationController). Deployment is a good fit for managing a stateless application workload on your cluster, where any Pod in the Deployment is interchangeable and can be replaced if needed.</p></li><li><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noreferrer">StatefulSet</a> lets you run one or more related Pods that do track state somehow. For example, if your workload records data persistently, you can run a StatefulSet that matches each Pod with a <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noreferrer">PersistentVolume</a>. Your code, running in the Pods for that StatefulSet, can replicate data to other Pods in the same StatefulSet to improve overall resilience.</p></li><li><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noreferrer">DaemonSet</a> defines Pods that provide facilities that are local to nodes. Every time you add a node to your cluster that matches the specification in a DaemonSet, the control plane schedules a Pod for that DaemonSet onto the new node. Each pod in a DaemonSet performs a job similar to a system daemon on a classic Unix / POSIX server. A DaemonSet might be fundamental to the operation of your cluster, such as a plugin to run <a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-network-model" target="_blank" rel="noreferrer">cluster networking</a>, it might help you to manage the node, or it could provide optional behavior that enhances the container platform you are running.</p></li><li><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" target="_blank" rel="noreferrer">Job</a> and <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" target="_blank" rel="noreferrer">CronJob</a> provide different ways to define tasks that run to completion and then stop. You can use a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" target="_blank" rel="noreferrer">Job</a> to define a task that runs to completion, just once. You can use a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" target="_blank" rel="noreferrer">CronJob</a> to run the same Job multiple times according a schedule.</p></li></ul><p>In the wider Kubernetes ecosystem, you can find third-party workload resources that provide additional behaviors. Using a<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" target="_blank" rel="noreferrer"> custom resource definition</a>, you can add in a third-party workload resource if you want a specific behavior that&#39;s not part of Kubernetes&#39; core. For example, if you wanted to run a group of Pods for your application but stop work unless all the Pods are available (perhaps for some high-throughput distributed task), then you can implement or install an extension that does provide that feature.</p><h2 id="what-s-next" tabindex="-1">What&#39;s next <a class="header-anchor" href="#what-s-next" aria-label="Permalink to &quot;What&#39;s next&quot;">​</a></h2><p>As well as reading about each API kind for workload management, you can read how to do specific tasks:</p><ul><li><a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/" target="_blank" rel="noreferrer">Run a stateless application using a Deployment</a></li><li>Run a stateful application either as a <a href="https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/" target="_blank" rel="noreferrer">single instance</a> or as a <a href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/" target="_blank" rel="noreferrer">replicated set</a></li><li><a href="https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs/" target="_blank" rel="noreferrer">Run automated tasks with a CronJob</a></li></ul><p>To learn about Kubernetes&#39; mechanisms for separating code from configuration, visit <a href="https://kubernetes.io/docs/concepts/configuration/" target="_blank" rel="noreferrer">Configuration</a>.</p><p>There are two supporting concepts that provide backgrounds about how Kubernetes manages pods for applications:</p><ul><li><a href="https://kubernetes.io/docs/concepts/architecture/garbage-collection/" target="_blank" rel="noreferrer">Garbage collection</a> tidies up objects from your cluster after their owning resource has been removed.</li><li>The <a href="https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished/" target="_blank" rel="noreferrer">time-to-live after finished controller</a> removes Jobs once a defined time has passed since they completed.</li></ul><p>Once your application is running, you might want to make it available on the internet as a <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noreferrer">Service</a> or, for web application only, using an <a href="https://kubernetes.io/docs/concepts/services-networking/ingress" target="_blank" rel="noreferrer">Ingress</a>.</p>',14),s=[n];function i(l,c,d,p,u,h){return t(),o("div",null,s)}const b=e(a,[["render",i]]);export{k as __pageData,b as default};
