import{_ as e,o,c as t,Q as r}from"./chunks/framework.01af844e.js";const p=JSON.parse('{"title":"Pod Quality of Service Classes","description":"","frontmatter":{},"headers":[],"relativePath":"container/k8s/concept/workload/pod/pod_quality.md","filePath":"container/k8s/concept/workload/pod/pod_quality.md","lastUpdated":1694607182000}'),a={name:"container/k8s/concept/workload/pod/pod_quality.md"},s=r('<h1 id="pod-quality-of-service-classes" tabindex="-1">Pod Quality of Service Classes <a class="header-anchor" href="#pod-quality-of-service-classes" aria-label="Permalink to &quot;Pod Quality of Service Classes&quot;">​</a></h1><p>This page introduces Quality of Service (QoS) classes in Kubernetes, and explains how Kubernetes assigns a QoS class to each Pod as a consequence of the resource constraints that you specify for the containers in that Pod. Kubernetes relies on this classification to make decisions about which Pods to evict when there are not enough available resources on a Node.</p><h2 id="quality-of-service-classes" tabindex="-1">Quality of Service classes <a class="header-anchor" href="#quality-of-service-classes" aria-label="Permalink to &quot;Quality of Service classes&quot;">​</a></h2><p>Kubernetes classifies the Pods that you run and allocates each Pod into a specific quality of service (QoS) class. Kubernetes uses that classification to influence how different pods are handled. Kubernetes does this classification based on the <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" target="_blank" rel="noreferrer">resource requests</a> of the Containers in that Pod, along with how those requests relate to resource limits. This is known as Quality of Service (QoS) class. Kubernetes assigns every Pod a QoS class based on the resource requests and limits of its component Containers. QoS classes are used by Kubernetes to decide which Pods to evict from a Node experiencing <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/" target="_blank" rel="noreferrer">Node Pressure</a>. The possible QoS classes are <code>Guaranteed</code>, <code>Burstable</code>, and <code>BestEffort</code>. When a Node runs out of resources, Kubernetes will first evict <code>BestEffort</code> Pods running on that Node, followed by <code>Burstable</code> and finally <code>Guaranteed</code> Pods. When this eviction is due to resource pressure, only Pods exceeding resource requests are candidates for eviction.</p><h3 id="guaranteed" tabindex="-1">Guaranteed <a class="header-anchor" href="#guaranteed" aria-label="Permalink to &quot;Guaranteed&quot;">​</a></h3><p>Pods that are <code>Guaranteed</code> have the strictest resource limits and are least likely to face eviction. They are guaranteed not to be killed until they exceed their limits or there are no lower-priority Pods that can be preempted from the Node. They may not acquire resources beyond their specified limits. These Pods can also make use of exclusive CPUs using the <code>static</code> CPU management policy.</p><h4 id="criteria" tabindex="-1">Criteria <a class="header-anchor" href="#criteria" aria-label="Permalink to &quot;Criteria&quot;">​</a></h4><p>For a Pod to be given a QoS class of <code>Guaranteed</code>:</p><ul><li>Every Container in the Pod must have a memory limit and a memory request.</li><li>For every Container in the Pod, the memory limit must equal the memory request.</li><li>Every Container in the Pod must have a CPU limit and a CPU request.</li><li>For every Container in the Pod, the CPU limit must equal the CPU request.</li></ul><h3 id="burstable" tabindex="-1">Burstable <a class="header-anchor" href="#burstable" aria-label="Permalink to &quot;Burstable&quot;">​</a></h3><p>Pods that are <code>Burstable</code> have some lower-bound resource guarantees based on the request, but do not require a specific limit. If a limit is not specified, it defaults to a limit equivalent to the capacity of the Node, which allows the Pods to flexibly increase their resources if resources are available. In the event of Pod eviction due to Node resource pressure, these Pods are evicted only after all <code>BestEffort</code> Pods are evicted. Because a <code>Burstable</code> Pod can include a Container that has no resource limits or requests, a Pod that is <code>Burstable</code> can try to use any amount of node resources.</p><h4 id="criteria-1" tabindex="-1">Criteria <a class="header-anchor" href="#criteria-1" aria-label="Permalink to &quot;Criteria&quot;">​</a></h4><p>A Pod is given a QoS class of <code>Burstable</code> if:</p><ul><li>The Pod does not meet the criteria for QoS class <code>Guaranteed</code>.</li><li>At least one Container in the Pod has a memory or CPU request or limit.</li></ul><h3 id="besteffort" tabindex="-1">BestEffort <a class="header-anchor" href="#besteffort" aria-label="Permalink to &quot;BestEffort&quot;">​</a></h3><p>Pods in the <code>BestEffort</code> QoS class can use node resources that aren&#39;t specifically assigned to Pods in other QoS classes. For example, if you have a node with 16 CPU cores available to the kubelet, and you assign 4 CPU cores to a <code>Guaranteed</code> Pod, then a Pod in the <code>BestEffort</code> QoS class can try to use any amount of the remaining 12 CPU cores.</p><p>The kubelet prefers to evict <code>BestEffort</code> Pods if the node comes under resource pressure.</p><h4 id="criteria-2" tabindex="-1">Criteria <a class="header-anchor" href="#criteria-2" aria-label="Permalink to &quot;Criteria&quot;">​</a></h4><p>A Pod has a QoS class of <code>BestEffort</code> if it doesn&#39;t meet the criteria for either <code>Guaranteed</code> or <code>Burstable</code>. In other words, a Pod is <code>BestEffort</code> only if none of the Containers in the Pod have a memory limit or a memory request, and none of the Containers in the Pod have a CPU limit or a CPU request. Containers in a Pod can request other resources (not CPU or memory) and still be classified as <code>BestEffort</code>.</p><h2 id="memory-qos-with-cgroup-v2" tabindex="-1">Memory QoS with cgroup v2 <a class="header-anchor" href="#memory-qos-with-cgroup-v2" aria-label="Permalink to &quot;Memory QoS with cgroup v2&quot;">​</a></h2><p><em>FEATURE STATE</em>: <code>Kubernetes v1.22 [alpha]</code></p><p>Memory QoS uses the memory controller of cgroup v2 to guarantee memory resources in Kubernetes. Memory requests and limits of containers in pod are used to set specific interfaces <code>memory.min</code> and <code>memory.high</code> provided by the memory controller. When <code>memory.min</code> is set to memory requests, memory resources are reserved and never reclaimed by the kernel; this is how Memory QoS ensures memory availability for Kubernetes pods. And if memory limits are set in the container, this means that the system needs to limit container memory usage; Memory QoS uses <code>memory.high</code> to throttle workload approaching its memory limit, ensuring that the system is not overwhelmed by instantaneous memory allocation.</p><p>Memory QoS relies on QoS class to determine which settings to apply; however, these are different mechanisms that both provide controls over quality of service.</p><h2 id="some-behavior-is-independent-of-qos-class" tabindex="-1">Some behavior is independent of QoS class <a class="header-anchor" href="#some-behavior-is-independent-of-qos-class" aria-label="Permalink to &quot;Some behavior is independent of QoS class&quot;">​</a></h2><p>Certain behavior is independent of the QoS class assigned by Kubernetes. For example:</p><ul><li><p>Any Container exceeding a resource limit will be killed and restarted by the kubelet without affecting other Containers in that Pod.</p></li><li><p>If a Container exceeds its resource request and the node it runs on faces resource pressure, the Pod it is in becomes a candidate for <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/" target="_blank" rel="noreferrer">eviction</a>. If this occurs, all Containers in the Pod will be terminated. Kubernetes may create a replacement Pod, usually on a different node.</p></li><li><p>The resource request of a Pod is equal to the sum of the resource requests of its component Containers, and the resource limit of a Pod is equal to the sum of the resource limits of its component Containers.</p></li><li><p>The kube-scheduler does not consider QoS class when selecting which Pods to <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption" target="_blank" rel="noreferrer">preempt</a>. Preemption can occur when a cluster does not have enough resources to run all the Pods you defined.</p></li></ul><h2 id="what-s-next" tabindex="-1">What&#39;s next <a class="header-anchor" href="#what-s-next" aria-label="Permalink to &quot;What&#39;s next&quot;">​</a></h2><ul><li>Learn about <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" target="_blank" rel="noreferrer">resource management for Pods and Containers</a>.</li><li>Learn about <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/" target="_blank" rel="noreferrer">Node-pressure eviction</a>.</li><li>Learn about <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/" target="_blank" rel="noreferrer">Pod priority and preemption</a>.</li><li>Learn about <a href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" target="_blank" rel="noreferrer">Pod disruptions</a>.</li><li>Learn how to <a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/" target="_blank" rel="noreferrer">assign memory resources to containers and pods</a>.</li><li>Learn how to <a href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource/" target="_blank" rel="noreferrer">assign CPU resources to containers and pods</a>.</li><li>Learn how to <a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/" target="_blank" rel="noreferrer">configure Quality of Service for Pods</a>.</li></ul>',28),i=[s];function n(c,d,l,u,h,f){return o(),t("div",null,i)}const b=e(a,[["render",n]]);export{p as __pageData,b as default};
