import{_ as s,o as a,c as e,Q as n}from"./chunks/framework.01af844e.js";const E=JSON.parse('{"title":"Using async and await","description":"","frontmatter":{},"headers":[],"relativePath":"python/flask/user_guide/async.md","filePath":"python/flask/user_guide/async.md","lastUpdated":1693404008000}'),o={name:"python/flask/user_guide/async.md"},t=n(`<h1 id="using-async-and-await" tabindex="-1">Using async and await <a class="header-anchor" href="#using-async-and-await" aria-label="Permalink to &quot;Using async and await {#using-async-and-await}&quot;">​</a></h1><details class="details custom-block"><summary>Changelog</summary><p><em>New in version 2.0.</em></p></details><p>Routes, error handlers, before request, after request, and teardown functions can all be coroutine functions if Flask is installed with the <code>async</code> extra (<code>pip install flask[async]</code>). This allows views to be defined with <code>async def</code> and use <code>await</code>.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">@app.route</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;/get-data&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">get_data</span><span style="color:#E1E4E8;">():</span></span>
<span class="line"><span style="color:#E1E4E8;">    data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> async_db_query(</span><span style="color:#79B8FF;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> jsonify(data)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">@app.route</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;/get-data&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">async</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">get_data</span><span style="color:#24292E;">():</span></span>
<span class="line"><span style="color:#24292E;">    data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> async_db_query(</span><span style="color:#005CC5;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> jsonify(data)</span></span></code></pre></div><p>Pluggable class-based views also support handlers that are implemented as coroutines. This applies to the <code>dispatch_request()</code> method in views that inherit from the <code>flask.views.View</code> class, as well as all the HTTP method handlers in views that inherit from the <code>flask.views.MethodView</code> class.</p><div class="tip custom-block"><p class="custom-block-title">Using <code>async</code> on Windows on Python 3.8</p><p>Python 3.8 has a bug related to asyncio on Windows. If you encounter something like <code>ValueError: set_wakeup_fd only works in main thread</code>, please upgrade to Python 3.9.</p></div><div class="tip custom-block"><p class="custom-block-title">Using <code>async</code> with greenlet</p><p>When using gevent or eventlet to serve an application or patch the runtime, greenlet&gt;=1.0 is required. When using PyPy, PyPy&gt;=7.3.7 is required.</p></div><h2 id="performance" tabindex="-1">Performance <a class="header-anchor" href="#performance" aria-label="Permalink to &quot;Performance {#performance}&quot;">​</a></h2><p>Async functions require an event loop to run. Flask, as a WSGI application, uses one worker to handle one request/response cycle. When a request comes in to an async view, Flask will start an event loop in a thread, run the view function there, then return the result.</p><p>Each request still ties up one worker, even for async views. The upside is that you can run async code within a view, for example to make multiple concurrent database queries, HTTP requests to an external API, etc. However, the number of requests your application can handle at one time will remain the same.</p><p>Async is not inherently faster than sync code. Async is beneficial when performing concurrent IO-bound tasks, but will probably not improve CPU-bound tasks. Traditional Flask views will still be appropriate for most use cases, but Flask’s async support enables writing and using code that wasn’t possible natively before.</p><h2 id="background-tasks" tabindex="-1">Background tasks <a class="header-anchor" href="#background-tasks" aria-label="Permalink to &quot;Background tasks {#background-tasks}&quot;">​</a></h2><p>Async functions will run in an event loop until they complete, at which stage the event loop will stop. This means any additional spawned tasks that haven’t completed when the async function completes will be cancelled. Therefore you cannot spawn background tasks, for example via <code>asyncio.create_task</code>.</p><p>If you wish to use background tasks it is best to use a task queue to trigger background work, rather than spawn tasks in a view function. With that in mind you can spawn asyncio tasks by serving Flask with an ASGI server and utilising the asgiref WsgiToAsgi adapter as described in <a href="/python/flask/user_guide/deploy#asgi">ASGI</a>. This works as the adapter creates an event loop that runs continually.</p><h2 id="when-to-use-quart-instead" tabindex="-1">When to use Quart instead <a class="header-anchor" href="#when-to-use-quart-instead" aria-label="Permalink to &quot;When to use Quart instead {#when-to-use-quart-instead}&quot;">​</a></h2><p>Flask’s async support is less performant than async-first frameworks due to the way it is implemented. If you have a mainly async codebase it would make sense to consider <a href="https://github.com/pallets/quart" target="_blank" rel="noreferrer">Quart</a>. Quart is a reimplementation of Flask based on the <a href="/python/flask/user_guide/deploy#asgi">ASGI</a> standard instead of WSGI. This allows it to handle many concurrent requests, long running requests, and websockets without requiring multiple worker processes or threads.</p><p>It has also already been possible to run Flask with Gevent or Eventlet to get many of the benefits of async request handling. These libraries patch low-level Python functions to accomplish this, whereas <code>async/ await</code> and ASGI use standard, modern Python capabilities. Deciding whether you should use Flask, Quart, or something else is ultimately up to understanding the specific needs of your project.</p><h2 id="extensions" tabindex="-1">Extensions <a class="header-anchor" href="#extensions" aria-label="Permalink to &quot;Extensions {#extensions}&quot;">​</a></h2><p>Flask extensions predating Flask’s async support do not expect async views. If they provide decorators to add functionality to views, those will probably not work with async views because they will not await the function or be awaitable. Other functions they provide will not be awaitable either and will probably be blocking if called within an async view.</p><p>Extension authors can support async functions by utilising the <code>flask.Flask.ensure_sync()</code> method. For example, if the extension provides a view function decorator add <code>ensure_sync</code> before calling the decorated function,</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">extension</span><span style="color:#E1E4E8;">(func):</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">@wraps</span><span style="color:#E1E4E8;">(func)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">wrapper</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">args, </span><span style="color:#F97583;">**</span><span style="color:#E1E4E8;">kwargs):</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">...</span><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;"># Extension logic</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> current_app.ensure_sync(func)(</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">args, </span><span style="color:#F97583;">**</span><span style="color:#E1E4E8;">kwargs)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> wrapper</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">extension</span><span style="color:#24292E;">(func):</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">@wraps</span><span style="color:#24292E;">(func)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">wrapper</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">args, </span><span style="color:#D73A49;">**</span><span style="color:#24292E;">kwargs):</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">...</span><span style="color:#24292E;">  </span><span style="color:#6A737D;"># Extension logic</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> current_app.ensure_sync(func)(</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">args, </span><span style="color:#D73A49;">**</span><span style="color:#24292E;">kwargs)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> wrapper</span></span></code></pre></div><p>Check the changelog of the extension you want to use to see if they’ve implemented async support, or make a feature request or PR to them.</p><h2 id="other-event-loops" tabindex="-1">Other event loops <a class="header-anchor" href="#other-event-loops" aria-label="Permalink to &quot;Other event loops {#other-event-loops}&quot;">​</a></h2><p>At the moment Flask only supports <code>asyncio</code>. It&#39;s possible to override <code>flask.Flask.ensure_sync()</code> to change how async functions are wrapped to use a different library.</p>`,24),l=[t];function p(r,c,i,d,y,u){return a(),e("div",null,l)}const f=s(o,[["render",p]]);export{E as __pageData,f as default};
