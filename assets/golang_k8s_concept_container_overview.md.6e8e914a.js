import{_ as e,o as t,c as n,Q as a}from"./chunks/framework.01af844e.js";const f=JSON.parse('{"title":"Containers","description":"","frontmatter":{},"headers":[],"relativePath":"golang/k8s/concept/container/overview.md","filePath":"golang/k8s/concept/container/overview.md","lastUpdated":1694020305000}'),r={name:"golang/k8s/concept/container/overview.md"},o=a('<h1 id="containers" tabindex="-1">Containers <a class="header-anchor" href="#containers" aria-label="Permalink to &quot;Containers&quot;">​</a></h1><p>Each container that you run is repeatable; the standardization from having dependencies included means that you get the same behavior wherever you run it.</p><p>Containers decouple applications from the underlying host infrastructure. This makes deployment easier in different cloud or OS environments.</p><p>Each node in a Kubernetes cluster runs the containers that form the <a href="https://kubernetes.io/docs/concepts/workloads/pods/" target="_blank" rel="noreferrer">Pods</a> assigned to that node. Containers in a Pod are co-located and co-scheduled to run on the same node.</p><h2 id="container-images" tabindex="-1">Container images <a class="header-anchor" href="#container-images" aria-label="Permalink to &quot;Container images&quot;">​</a></h2><p>A <a href="https://kubernetes.io/docs/concepts/containers/images/" target="_blank" rel="noreferrer">container image</a> is a ready-to-run software package containing everything needed to run an application: the code and any runtime it requires, application and system libraries, and default values for any essential settings.</p><p>Containers are intended to be stateless and <a href="https://glossary.cncf.io/immutable-infrastructure/" target="_blank" rel="noreferrer">immutable</a>: you should not change the code of a container that is already running. If you have a containerized application and want to make changes, the correct process is to build a new image that includes the change, then recreate the container to start from the updated image.</p><h2 id="container-runtimes" tabindex="-1">Container runtimes <a class="header-anchor" href="#container-runtimes" aria-label="Permalink to &quot;Container runtimes&quot;">​</a></h2><p>A fundamental component that empowers Kubernetes to run containers effectively. It is responsible for managing the execution and lifecycle of containers within the Kubernetes environment.</p><p>Kubernetes supports container runtimes such as containerd, CRI-O, and any other implementation of the <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noreferrer">Kubernetes CRI (Container Runtime Interface)</a>.</p><p>Usually, you can allow your cluster to pick the default container runtime for a Pod. If you need to use more than one container runtime in your cluster, you can specify the <a href="https://kubernetes.io/docs/concepts/containers/runtime-class/" target="_blank" rel="noreferrer">RuntimeClass</a> for a Pod to make sure that Kubernetes runs those containers using a particular container runtime.</p><p>You can also use RuntimeClass to run different Pods with the same container runtime but with different settings.</p><p><a href="https://kubernetes.io/docs/concepts/containers/container-environment/" target="_blank" rel="noreferrer">Container Environment</a></p><p><a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noreferrer">Container Lifecycle Hooks</a></p>',14),i=[o];function s(c,u,l,d,h,p){return t(),n("div",null,i)}const g=e(r,[["render",s]]);export{f as __pageData,g as default};
