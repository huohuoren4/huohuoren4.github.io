import{_ as e,o as s,c as o,V as a}from"./chunks/framework.48c56699.js";const f=JSON.parse('{"title":"Session Interface","description":"","frontmatter":{},"headers":[],"relativePath":"python/flask/api_reference/session_interface.md","filePath":"python/flask/api_reference/session_interface.md"}'),i={name:"python/flask/api_reference/session_interface.md"},t=a('<h1 id="session-interface" tabindex="-1">Session Interface <a class="header-anchor" href="#session-interface" aria-label="Permalink to &quot;Session Interface&quot;">​</a></h1><details class="details custom-block"><summary>Changelog</summary><p><em>New in version 0.8.</em></p></details><p>The session interface provides a simple way to replace the session implementation that Flask is using.</p><h2 id="class-flask-sessions-sessioninterface" tabindex="-1"><code>class</code> flask.sessions.SessionInterface <a class="header-anchor" href="#class-flask-sessions-sessioninterface" aria-label="Permalink to &quot;`class` flask.sessions.SessionInterface&quot;">​</a></h2><p>The basic interface you have to implement in order to replace the default session interface which uses werkzeug’s securecookie implementation. The only methods you have to implement are <code>open_session()</code> and <code>save_session()</code>, the others have useful defaults which you don’t need to change.</p><p>The session object returned by the <code>open_session()</code> method has to provide a dictionary like interface plus the properties and methods from the <code>SessionMixin</code>. We recommend just subclassing a dict and adding that mixin:</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Session</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">dict</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SessionMixin</span><span style="color:#89DDFF;">):</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">pass</span></span></code></pre></div><p>If <code>open_session()</code> returns <code>None</code> Flask will call into <code>make_null_session()</code> to create a session that acts as replacement if the session support cannot work because some requirement is not fulfilled. The default <code>NullSession</code> class that is created will complain that the secret key was not set.</p><p>To replace the session interface on an application all you have to do is to assign <code>flask.Flask.session_interface</code>:</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Flask</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">__name__</span><span style="color:#89DDFF;">)</span></span>\n<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">session_interface</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MySessionInterface</span><span style="color:#89DDFF;">()</span></span></code></pre></div><p>Multiple requests with the same session may be sent and handled concurrently. When implementing a new session interface, consider whether reads or writes to the backing store must be synchronized. There is no guarantee on the order in which the session for each request is opened or saved, it will occur in the order that requests begin and end processing.</p><details class="details custom-block"><summary>Changelog</summary><p><em>New in version 0.8.</em></p></details><ul><li><h3 id="get-cookie-domain-app" tabindex="-1">get_cookie_domain(<code>app</code>) <a class="header-anchor" href="#get-cookie-domain-app" aria-label="Permalink to &quot;get_cookie_domain(`app`)&quot;">​</a></h3><p>The value of the <code>Domain</code> parameter on the session cookie. If not set, browsers will only send the cookie to the exact domain it was set from. Otherwise, they will send it to any subdomain of the given value as well.</p><p>Uses the <code>SESSION_COOKIE_DOMAIN</code> config.</p><p><em>Changed in version 2.3</em>: Not set by default, does not fall back to <code>SERVER_NAME</code>.</p><p><em>Parameters</em>:</p><ul><li><code>app (Flask)</code> –</li></ul><p><em>Return type</em>: <code>str | None</code></p></li><li><h3 id="get-cookie-httponly-app" tabindex="-1">get_cookie_httponly(<code>app</code>) <a class="header-anchor" href="#get-cookie-httponly-app" aria-label="Permalink to &quot;get_cookie_httponly(`app`)&quot;">​</a></h3><p>Returns <code>True</code> if the session cookie should be httponly. This currently just returns the value of the <code>SESSION_COOKIE_HTTPONLY</code> config var.</p><p><em>Parameters</em>:</p><ul><li><code>app (Flask)</code> –</li></ul><p><em>Return type</em>: <code>bool</code></p></li><li><h3 id="get-cookie-name-app" tabindex="-1">get_cookie_name(<code>app</code>) <a class="header-anchor" href="#get-cookie-name-app" aria-label="Permalink to &quot;get_cookie_name(`app`)&quot;">​</a></h3><p>The name of the session cookie. Uses <code>app.config[“SESSION_COOKIE_NAME”]</code>.</p><p><em>Parameters</em>:</p><ul><li><code>app (Flask)</code> –</li></ul><p><em>Return type</em>: <code>str</code></p></li><li><h3 id="get-cookie-path-app" tabindex="-1">get_cookie_path(<code>app</code>) <a class="header-anchor" href="#get-cookie-path-app" aria-label="Permalink to &quot;get_cookie_path(`app`)&quot;">​</a></h3><p>Returns the path for which the cookie should be valid. The default implementation uses the value from the <code>SESSION_COOKIE_PATH</code> config var if it’s set, and falls back to <code>APPLICATION_ROOT</code> or uses <code>/</code> if it’s <code>None</code>.</p><p><em>Parameters</em>:</p><ul><li><code>app (Flask)</code> –</li></ul><p><em>Return type</em>: <code>str</code></p></li><li><h3 id="get-cookie-samesite-app" tabindex="-1">get_cookie_samesite(<code>app</code>) <a class="header-anchor" href="#get-cookie-samesite-app" aria-label="Permalink to &quot;get_cookie_samesite(`app`)&quot;">​</a></h3><p>Return <code>&#39;Strict&#39;</code> or <code>&#39;Lax&#39;</code> if the cookie should use the <code>SameSite</code> attribute. This currently just returns the value of the <code>SESSION_COOKIE_SAMESITE</code> setting.</p><p><em>Parameters</em>:</p><ul><li><code>app (Flask)</code> –</li></ul><p><em>Return type</em>: <code>str</code></p></li><li><h3 id="get-cookie-secure-app" tabindex="-1">get_cookie_secure(<code>app</code>) <a class="header-anchor" href="#get-cookie-secure-app" aria-label="Permalink to &quot;get_cookie_secure(`app`)&quot;">​</a></h3><p>Returns <code>True</code> if the cookie should be secure. This currently just returns the value of the <code>SESSION_COOKIE_SECURE</code> setting.</p><p><em>Parameters</em>:</p><ul><li><code>app (Flask)</code> –</li></ul><p><em>Return type</em>: <code>bool</code></p></li><li><h3 id="get-expiration-time-app-session" tabindex="-1">get_expiration_time(<code>app, session</code>) <a class="header-anchor" href="#get-expiration-time-app-session" aria-label="Permalink to &quot;get_expiration_time(`app, session`)&quot;">​</a></h3><p>A helper method that returns an expiration date for the session or <code>None</code> if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.</p><p><em>Parameters</em>:</p><ul><li><p><code>app (Flask)</code> –</p></li><li><p><code>session (SessionMixin)</code> –</p></li></ul><p><em>Return type</em>: <code>datetime | None</code></p></li><li><h3 id="is-null-session-obj" tabindex="-1">is_null_session(<code>obj</code>) <a class="header-anchor" href="#is-null-session-obj" aria-label="Permalink to &quot;is_null_session(`obj`)&quot;">​</a></h3><p>Checks if a given object is a null session. Null sessions are not asked to be saved.</p><p>This checks if the object is an instance of <code>null_session_class</code> by default.</p><p><em>Parameters</em>:</p><ul><li><code>obj (object)</code> –</li></ul><p><em>Return type</em>: <code>bool</code></p></li><li><h3 id="make-null-session-app" tabindex="-1">make_null_session(<code>app</code>) <a class="header-anchor" href="#make-null-session-app" aria-label="Permalink to &quot;make_null_session(`app`)&quot;">​</a></h3><p>Creates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed.</p><p>This creates an instance of <code>null_session_class</code> by default.</p><p><em>Parameters</em>:</p><ul><li><code>app (Flask)</code> –</li></ul><p><em>Return type</em>: <code>NullSession</code></p></li><li><h3 id="null-session-class" tabindex="-1">null_session_class <a class="header-anchor" href="#null-session-class" aria-label="Permalink to &quot;null_session_class&quot;">​</a></h3><p><code>make_null_session()</code> will look here for the class that should be created when a null session is requested. Likewise the <code>is_null_session()</code> method will perform a typecheck against this type.</p><p>alias of <code>NullSession</code></p></li><li><h3 id="open-session-app-request" tabindex="-1">open_session(<code>app, request</code>) <a class="header-anchor" href="#open-session-app-request" aria-label="Permalink to &quot;open_session(`app, request`)&quot;">​</a></h3><p>This is called at the beginning of each request, after pushing the request context, before matching the URL.</p><p>This must return an object which implements a dictionary-like interface as well as the <code>SessionMixin</code> interface.</p><p>This will return None to indicate that loading failed in some way that is not immediately an error. The request context will fall back to <code>using make_null_session()</code> in this case.</p><p><em>Parameters</em>:</p><ul><li><p><code>app (Flask)</code> –</p></li><li><p><code>request (Request)</code> –</p></li></ul><p><em>Return type</em>: <code>SessionMixin | None</code></p></li><li><h3 id="pickle-based-false" tabindex="-1">pickle_based = <code>False</code> <a class="header-anchor" href="#pickle-based-false" aria-label="Permalink to &quot;pickle_based = `False`&quot;">​</a></h3><p>A flag that indicates if the session interface is pickle based. This can be used by <code>Flask</code> extensions to make a decision in regards to how to deal with the session object.</p><details class="details custom-block"><summary>Changelog</summary><p><em>New in version 0.10.</em></p></details></li><li><h3 id="save-session-app-session-response" tabindex="-1">save_session(<code>app, session, response</code>) <a class="header-anchor" href="#save-session-app-session-response" aria-label="Permalink to &quot;save_session(`app, session, response`)&quot;">​</a></h3><p>This is called at the end of each request, after generating a response, before removing the request context. It is skipped if <code>is_null_session()</code> returns <code>True</code>.</p><p><em>Parameters</em>:</p><ul><li><p><code>app (Flask)</code> –</p></li><li><p><code>session (SessionMixin)</code> –</p></li><li><p><code>response (Response)</code> –</p></li></ul><p><em>Return type</em>: <code>None</code></p></li><li><h3 id="should-set-cookie-app-session" tabindex="-1">should_set_cookie(<code>app, session</code>) <a class="header-anchor" href="#should-set-cookie-app-session" aria-label="Permalink to &quot;should_set_cookie(`app, session`)&quot;">​</a></h3><p>Used by session backends to determine if a <code>Set-Cookie</code> header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the <code>SESSION_REFRESH_EACH_REQUEST</code> config is true, the cookie is always set.</p><p>This check is usually skipped if the session was deleted.</p><details class="details custom-block"><summary>Changelog</summary><p><em>New in version 0.11.</em></p></details><p><em>Parameters</em>:</p><ul><li><p><code>app (Flask)</code> –</p></li><li><p><code>session (SessionMixin)</code> –</p></li></ul><p><em>Return type</em>: <code>bool</code></p></li></ul><h2 id="class-flask-sessions-securecookiesessioninterface" tabindex="-1"><code>class</code> flask.sessions.SecureCookieSessionInterface <a class="header-anchor" href="#class-flask-sessions-securecookiesessioninterface" aria-label="Permalink to &quot;`class` flask.sessions.SecureCookieSessionInterface&quot;">​</a></h2><p>The default session interface that stores sessions in signed cookies through the itsdangerous module.</p><ul><li><h3 id="static-digest-method-string-b-usedforsecurity-true" tabindex="-1"><code>static</code> digest_method(<code>string=b&#39;&#39;, *, usedforsecurity=True</code>) <a class="header-anchor" href="#static-digest-method-string-b-usedforsecurity-true" aria-label="Permalink to &quot;`static` digest_method(`string=b&#39;&#39;, *, usedforsecurity=True`)&quot;">​</a></h3><p>the hash function to use for the signature. The default is sha1</p></li><li><h3 id="key-derivation-hmac" tabindex="-1">key_derivation = <code>&#39;hmac&#39;</code> <a class="header-anchor" href="#key-derivation-hmac" aria-label="Permalink to &quot;key_derivation = `&#39;hmac&#39;`&quot;">​</a></h3><p>the name of the itsdangerous supported key derivation. The default is <code>hmac</code>.</p></li><li><h3 id="open-session-app-request-1" tabindex="-1">open_session(<code>app, request</code>) <a class="header-anchor" href="#open-session-app-request-1" aria-label="Permalink to &quot;open_session(`app, request`)&quot;">​</a></h3><p>This is called at the beginning of each request, after pushing the request context, before matching the URL.</p><p>This must return an object which implements a dictionary-like interface as well as the <code>SessionMixin</code> interface.</p><p>This will return <code>None</code> to indicate that loading failed in some way that is not immediately an error. The request context will fall back to using <code>make_null_session()</code> in this case.</p><p><em>Parameters</em>:</p><ul><li><p><code>app (Flask)</code> –</p></li><li><p><code>request (Request)</code> –</p></li></ul><p><em>Return type</em>: <code>SecureCookieSession | None</code></p></li><li><h3 id="salt-cookie-session" tabindex="-1">salt = <code>&#39;cookie-session&#39;</code> <a class="header-anchor" href="#salt-cookie-session" aria-label="Permalink to &quot;salt = `&#39;cookie-session&#39;`&quot;">​</a></h3></li></ul><p>the salt that should be applied on top of the secret key for the signing of cookie based sessions.</p><ul><li><h3 id="save-session-app-session-response-1" tabindex="-1">save_session(<code>app, session, response</code>) <a class="header-anchor" href="#save-session-app-session-response-1" aria-label="Permalink to &quot;save_session(`app, session, response`)&quot;">​</a></h3><p>This is called at the end of each request, after generating a response, before removing the request context. It is skipped if <code>is_null_session()</code> returns <code>True</code>.</p><p><em>Parameters</em>:</p><ul><li><p><code>app (Flask)</code> –</p></li><li><p><code>session (SessionMixin)</code> –</p></li><li><p><code>response (Response)</code> –</p></li></ul><p><em>Return type</em>: <code>None</code></p></li><li><h3 id="serializer-flask-json-tag-taggedjsonserializer-object" tabindex="-1">serializer = <code>&lt;flask.json.tag.TaggedJSONSerializer object&gt;</code> <a class="header-anchor" href="#serializer-flask-json-tag-taggedjsonserializer-object" aria-label="Permalink to &quot;serializer = `&lt;flask.json.tag.TaggedJSONSerializer object&gt;`&quot;">​</a></h3><p>A python serializer for the payload. The default is a compact <code>JSON</code> derived serializer with support for some extra Python types such as datetime objects or tuples.</p></li><li><h3 id="session-class" tabindex="-1">session_class <a class="header-anchor" href="#session-class" aria-label="Permalink to &quot;session_class&quot;">​</a></h3><p>alias of <code>SecureCookieSession</code></p></li></ul><h2 id="class-flask-sessions-securecookiesession-initial-none" tabindex="-1"><code>class</code> flask.sessions.SecureCookieSession(<code>initial=None</code>) <a class="header-anchor" href="#class-flask-sessions-securecookiesession-initial-none" aria-label="Permalink to &quot;`class` flask.sessions.SecureCookieSession(`initial=None`)&quot;">​</a></h2><p>Base class for sessions based on signed cookies.</p><p>This session backend will set the <code>modified</code> and <code>accessed</code> attributes. It cannot reliably track whether a session is new (vs. empty), so new remains hard coded to <code>False</code>.</p><ul><li><p><em>Parameters</em>:</p><ul><li><code>initial (t.Any)</code> –</li></ul></li><li><h3 id="accessed-false" tabindex="-1">accessed = <code>False</code> <a class="header-anchor" href="#accessed-false" aria-label="Permalink to &quot;accessed = `False`&quot;">​</a></h3><p>header, which allows caching proxies to cache different pages for different users.</p></li><li><h3 id="get-key-default-none" tabindex="-1">get(<code>key, default=None</code>) <a class="header-anchor" href="#get-key-default-none" aria-label="Permalink to &quot;get(`key, default=None`)&quot;">​</a></h3><p>Return the value for key if key is in the dictionary, else default.</p><p><em>Parameters</em>:</p><ul><li><p><code>key (str)</code> –</p></li><li><p><code>default (Any | None)</code> –</p></li></ul><p><em>Return type</em>: <code>Any</code></p></li><li><h3 id="modified-false" tabindex="-1">modified = <code>False</code> <a class="header-anchor" href="#modified-false" aria-label="Permalink to &quot;modified = `False`&quot;">​</a></h3><p>When data is changed, this is set to <code>True</code>. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to <code>True</code> manually when modifying that data. The session cookie will only be written to the response if this is <code>True</code>.</p></li><li><h3 id="setdefault-key-default-none" tabindex="-1">setdefault(<code>key, default=None</code>) <a class="header-anchor" href="#setdefault-key-default-none" aria-label="Permalink to &quot;setdefault(`key, default=None`)&quot;">​</a></h3><p>Insert key with a value of default if key is not in the dictionary.</p><p>Return the value for key if key is in the dictionary, else default.</p><p><em>Parameters</em>:</p><ul><li><p><code>key (str</code>) –</p></li><li><p><code>default (Any | None)</code> –</p></li></ul><p><em>Return type</em>: <code>Any</code></p></li></ul><h2 id="class-flask-sessions-nullsession-initial-none" tabindex="-1"><code>class</code> flask.sessions.NullSession(<code>initial=None)</code> <a class="header-anchor" href="#class-flask-sessions-nullsession-initial-none" aria-label="Permalink to &quot;`class` flask.sessions.NullSession(`initial=None)`&quot;">​</a></h2><p>Class used to generate nicer error messages if sessions are not available. Will still allow read-only access to the empty session but fail on setting.</p><ul><li><p><em>Parameters</em>:</p><ul><li><code>initial (t.Any)</code> –</li></ul></li><li><h3 id="clear-→-none" tabindex="-1"><code>clear()</code> → <code>None</code> <a class="header-anchor" href="#clear-→-none" aria-label="Permalink to &quot;`clear()` → `None`&quot;">​</a></h3><p>Remove all items from D.</p><p><em>Parameters</em>:</p><ul><li><p><code>args (Any)</code> –</p></li><li><p><code>kwargs (Any)</code> –</p></li></ul><p><em>Return type</em>: <code>NoReturn</code></p></li><li><h3 id="pop-k-d-→-v" tabindex="-1">pop(<code>k[, d]</code>) → <code>v</code> <a class="header-anchor" href="#pop-k-d-→-v" aria-label="Permalink to &quot;pop(`k[, d]`) → `v`&quot;">​</a></h3><p>remove specified key and return the corresponding value.</p><p>If the key is not found, return the default if given; otherwise, raise a <code>KeyError</code>.</p><p><em>Parameters</em>:</p><ul><li><p><code>args (Any)</code> –</p></li><li><p><code>kwargs (Any)</code> –</p></li></ul><p><em>Return type</em>: <code>NoReturn</code></p></li><li><h3 id="popitem-args-kwargs" tabindex="-1">popitem(<code>*args, **kwargs</code>) <a class="header-anchor" href="#popitem-args-kwargs" aria-label="Permalink to &quot;popitem(`*args, **kwargs`)&quot;">​</a></h3><p>Remove and return a <code>(key, value)</code> pair as a 2-tuple.</p><p>Pairs are returned in <code>LIFO</code> (last-in, first-out) order. Raises <code>KeyError</code> if the dict is empty.</p><p><em>Parameters</em>:</p><ul><li><p><code>args (Any)</code> –</p></li><li><p><code>kwargs (Any)</code> –</p></li></ul><p><em>Return type</em>: <code>NoReturn</code></p></li><li><h3 id="setdefault-args-kwargs" tabindex="-1">setdefault(<code>*args, **kwargs</code>) <a class="header-anchor" href="#setdefault-args-kwargs" aria-label="Permalink to &quot;setdefault(`*args, **kwargs`)&quot;">​</a></h3><p>Insert key with a value of default if key is not in the dictionary.</p><p>Return the value for key if key is in the dictionary, else default.</p><p><em>Parameters</em>:</p><ul><li><p><code>args (Any)</code> –</p></li><li><p><code>kwargs (Any)</code> –</p></li></ul><p><em>Return type</em>: <code>NoReturn</code></p></li><li><h3 id="update-e-f-→-none" tabindex="-1">update(<code>[E, ]**F</code>) → <code>None</code> <a class="header-anchor" href="#update-e-f-→-none" aria-label="Permalink to &quot;update(`[E, ]**F`) → `None`&quot;">​</a></h3><p>Update <code>D</code> from dict/iterable <code>E</code> and <code>F</code>.</p><p>If <code>E</code> is present and has a <code>.keys()</code> method, then does: <code>for k in E: D[k] = E[k] If E</code> is present and lacks a <code>.keys()</code> method, then does: <code>for k, v in E: D[k] = v</code> In either case, this is followed by: <code>for k in F: D[k] = F[k]</code></p><p><em>Parameters</em>:</p><ul><li><p><code>args (Any)</code> –</p></li><li><p><code>kwargs (Any)</code> –</p></li></ul><p><em>Return type</em>: <code>NoReturn</code></p></li></ul><h2 id="class-flask-sessions-sessionmixin" tabindex="-1">class flask.sessions.SessionMixin <a class="header-anchor" href="#class-flask-sessions-sessionmixin" aria-label="Permalink to &quot;class flask.sessions.SessionMixin&quot;">​</a></h2><p>Expands a basic dictionary with session attributes.</p><ul><li><h3 id="accessed-true" tabindex="-1">accessed = <code>True</code> <a class="header-anchor" href="#accessed-true" aria-label="Permalink to &quot;accessed = `True`&quot;">​</a></h3><p>Some implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to <code>True</code>.</p><ul><li><h3 id="modified-true" tabindex="-1">modified = <code>True</code> <a class="header-anchor" href="#modified-true" aria-label="Permalink to &quot;modified = `True`&quot;">​</a></h3></li></ul><p>Some implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to ·.</p><ul><li><h3 id="property-permanent-bool" tabindex="-1"><code>property</code> permanent: <code>bool</code> <a class="header-anchor" href="#property-permanent-bool" aria-label="Permalink to &quot;`property` permanent: `bool`&quot;">​</a></h3></li></ul><p>This reflects the <code>&#39;_permanent&#39;</code> key in the dict.</p></li></ul><details class="details custom-block"><summary>Notice</summary><p>The <code>PERMANENT_SESSION_LIFETIME</code> config can be an integer or <code>timedelta</code>. The <code>permanent_session_lifetime</code> attribute is always a <code>timedelta</code>.</p></details>',29),n=[t];function l(c,r,d,p,h,u){return s(),o("div",null,n)}const k=e(i,[["render",l]]);export{f as __pageData,k as default};
