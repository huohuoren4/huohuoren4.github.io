import{_ as e,o as a,c as t,X as s}from"./chunks/framework.b5656a4e.js";const y=JSON.parse('{"title":"Application Structure and Lifecycle","description":"","frontmatter":{},"headers":[],"relativePath":"python/flask/user_guide/app_structure.md","filePath":"python/flask/user_guide/app_structure.md","lastUpdated":1693328004000}'),o={name:"python/flask/user_guide/app_structure.md"},n=s(`<h1 id="application-structure-and-lifecycle" tabindex="-1">Application Structure and Lifecycle <a class="header-anchor" href="#application-structure-and-lifecycle" aria-label="Permalink to &quot;Application Structure and Lifecycle {#application-structure-and-lifecycle}&quot;">​</a></h1><p>Flask makes it pretty easy to write a web application. But there are quite a few different parts to an application and to each request it handles. Knowing what happens during application setup, serving, and handling requests will help you know what’s possible in Flask and how to structure your application.</p><h2 id="application-setup" tabindex="-1">Application Setup <a class="header-anchor" href="#application-setup" aria-label="Permalink to &quot;Application Setup {#application-setup}&quot;">​</a></h2><p>The first step in creating a Flask application is creating the application object. Each Flask application is an instance of the <code>Flask</code> class, which collects all configuration, extensions, and views.</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> flask </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> Flask</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Flask</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">__name__</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">config</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">from_mapping</span><span style="color:#89DDFF;">(</span></span>
<span class="line"><span style="color:#82AAFF;">    </span><span style="color:#A6ACCD;font-style:italic;">SECRET_KEY</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">dev</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">config</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">from_prefixed_env</span><span style="color:#89DDFF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">route</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#C792EA;">def</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">index</span><span style="color:#89DDFF;">():</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello, World!</span><span style="color:#89DDFF;">&quot;</span></span></code></pre></div><p>This is known as the “application setup phase”, it’s the code you write that’s outside any view functions or other handlers. It can be split up between different modules and sub-packages, but all code that you want to be part of your application must be imported in order for it to be registered.</p><p>All application setup must be completed before you start serving your application and handling requests. This is because WSGI servers divide work between multiple workers, or can be distributed across multiple machines. If the configuration changed in one worker, there’s no way for Flask to ensure consistency between other workers.</p><p>Flask tries to help developers catch some of these setup ordering issues by showing an error if setup-related methods are called after requests are handled. In that case you’ll see this error:</p><ul><li>The setup method ‘route’ can no longer be called on the application. It has already handled its first request, any changes will not be applied consistently. Make sure all imports, decorators, functions, etc. needed to set up the application are done before running it.</li></ul><p>However, it is not possible for Flask to detect all cases of out-of-order setup. In general, don’t do anything to modify the <code>Flask</code> app object and <code>Blueprint</code> objects from within view functions that run during requests. This includes:</p><ul><li><p>Adding routes, view functions, and other request handlers with <code>@app.route</code>, <code>@app.errorhandler</code>, <code>@app.before_request</code>, etc.</p></li><li><p>Registering blueprints.</p></li><li><p>Loading configuration with <code>app.config</code>.</p></li><li><p>Setting up the Jinja template environment with <code>app.jinja_env</code>.</p></li><li><p>Setting a session interface, instead of the default itsdangerous cookie.</p></li><li><p>Setting a JSON provider with <code>app.json</code>, instead of the default provider.</p></li><li><p>Creating and initializing Flask extensions.</p></li></ul><h2 id="serving-the-application" tabindex="-1">Serving the Application <a class="header-anchor" href="#serving-the-application" aria-label="Permalink to &quot;Serving the Application {#serving-the-application}&quot;">​</a></h2><p>Flask is a WSGI application framework. The other half of WSGI is the WSGI server. During development, Flask, through Werkzeug, provides a development WSGI server with the <code>flask run</code> CLI command. When you are done with development, use a production server to serve your application, see <a href="/python/flask/user_guide/deploy#deploying-to-production">Deploying to Production</a>.</p><p>Regardless of what server you’re using, it will follow the <a href="https://peps.python.org/pep-3333/" target="_blank" rel="noreferrer">PEP 3333</a> WSGI spec. The WSGI server will be told how to access your Flask application object, which is the WSGI application. Then it will start listening for HTTP requests, translate the request data into a WSGI environ, and call the WSGI application with that data. The WSGI application will return data that is translated into an HTTP response.</p><ol><li><p>Browser or other client makes HTTP request.</p></li><li><p>WSGI server receives request.</p></li><li><p>WSGI server converts HTTP data to WSGI <code>environ</code> dict.</p></li><li><p>WSGI server calls WSGI application with the <code>environ</code>.</p></li><li><p>Flask, the WSGI application, does all its internal processing to route the request to a view function, handle errors, etc.</p></li><li><p>Flask translates View function return into WSGI response data, passes it to WSGI server.</p></li><li><p>WSGI server creates and send an HTTP response.</p></li><li><p>Client receives the HTTP response.</p></li></ol><h3 id="middleware" tabindex="-1">Middleware <a class="header-anchor" href="#middleware" aria-label="Permalink to &quot;Middleware {#middleware}&quot;">​</a></h3><p>The WSGI application above is a callable that behaves in a certain way. Middleware is a WSGI application that wraps another WSGI application. It’s a similar concept to Python decorators. The outermost middleware will be called by the server. It can modify the data passed to it, then call the WSGI application (or further middleware) that it wraps, and so on. And it can take the return value of that call and modify it further.</p><p>From the WSGI server’s perspective, there is one WSGI application, the one it calls directly. Typically, Flask is the “real” application at the end of the chain of middleware. But even Flask can call further WSGI applications, although that’s an advanced, uncommon use case.</p><p>A common middleware you’ll see used with Flask is Werkzeug’s <a href="https://werkzeug.palletsprojects.com/en/2.3.x/middleware/proxy_fix/#werkzeug.middleware.proxy_fix.ProxyFix" target="_blank" rel="noreferrer">ProxyFix</a>, which modifies the request to look like it came directly from a client even if it passed through HTTP proxies on the way. There are other middleware that can handle serving static files, authentication, etc.</p><h2 id="how-a-request-is-handled" tabindex="-1">How a Request is Handled <a class="header-anchor" href="#how-a-request-is-handled" aria-label="Permalink to &quot;How a Request is Handled {#how-a-request-is-handled}&quot;">​</a></h2><p>For us, the interesting part of the steps above is when Flask gets called by the WSGI server (or middleware). At that point, it will do quite a lot to handle the request and generate the response. At the most basic, it will match the URL to a view function, call the view function, and pass the return value back to the server. But there are many more parts that you can use to customize its behavior.</p><ol><li><p>WSGI server calls the Flask object, which calls <code>Flask.wsgi_app()</code>.</p></li><li><p>A <code>RequestContext</code> object is created. This converts the WSGI <code>environ</code> dict into a <code>Request</code> object. It also creates an <code>AppContext</code> object.</p></li><li><p>The <a href="/python/flask/user_guide/app_context#the-application-context">app context</a> is pushed, which makes <code>current_app</code> and <code>g</code> available.</p></li><li><p>The <code>appcontext_pushed</code> signal is sent.</p></li><li><p>The <a href="/python/flask/user_guide/request_context#the-request-context">request context</a> is pushed, which makes <code>request</code> and <code>session</code> available.</p></li><li><p>The session is opened, loading any existing session data using the app’s <code>session_interface</code>, an instance of <code>SessionInterface</code>.</p></li><li><p>The URL is matched against the URL rules registered with the <code>route()</code> decorator during application setup. If there is no match, the error - usually a 404, 405, or redirect - is stored to be handled later.</p></li><li><p>The <code>request_started</code> signal is sent.</p></li><li><p>Any <code>url_value_preprocessor()</code> decorated functions are called.</p></li><li><p>Any <code>before_request()</code> decorated functions are called. If any of these function returns a value it is treated as the response immediately.</p></li><li><p>If the URL didn’t match a route a few steps ago, that error is raised now.</p></li><li><p>The <code>route()</code> decorated view function associated with the matched URL is called and returns a value to be used as the response.</p></li><li><p>If any step so far raised an exception, and there is an <code>errorhandler()</code> decorated function that matches the exception class or HTTP error code, it is called to handle the error and return a response.</p></li><li><p>Whatever returned a response value - a before request function, the view, or an error handler, that value is converted to a <code>Response</code> object.</p></li><li><p>Any <code>after_this_request()</code> decorated functions are called, then cleared.</p></li><li><p>Any <code>after_request()</code> decorated functions are called, which can modify the response object.</p></li><li><p>The session is saved, persisting any modified session data using the app’s <code>session_interface</code>.</p></li><li><p>The <code>request_finished</code> signal is sent.</p></li><li><p>If any step so far raised an exception, and it was not handled by an error handler function, it is handled now. HTTP exceptions are treated as responses with their corresponding status code, other exceptions are converted to a generic 500 response. The <code>got_request_exception</code> signal is sent.</p></li><li><p>The response object’s status, headers, and body are returned to the WSGI server.</p></li><li><p>Any <code>teardown_request()</code> decorated functions are called.</p></li><li><p>The <code>request_tearing_down</code> signal is sent.</p></li><li><p>The request context is popped, <code>request</code> and <code>session</code> are no longer available.</p></li><li><p>Any <code>teardown_appcontext()</code> decorated functions are called.</p></li><li><p>The <code>appcontext_tearing_down</code> signal is sent.</p></li><li><p>The app context is popped, <code>current_app</code> and <code>g</code> are no longer available.</p></li><li><p>The <code>appcontext_popped</code> signal is sent.</p></li></ol><p>There are even more decorators and customization points than this, but that aren’t part of every request lifecycle. They’re more specific to certain things you might use during a request, such as templates, building URLs, or handling JSON data. See the rest of this documentation, as well as the <a href="/python/flask/api_reference/app_obj#api">API</a> to explore further.</p>`,23),i=[n];function r(l,p,c,d,h,u){return a(),t("div",null,i)}const g=e(o,[["render",r]]);export{y as __pageData,g as default};
